Hereâ€™s a full project specification in the style of your CS32 TaskList spec â€” but for implementing a Vector Class from Scratch to learn operator overloading, templates, and move semantics.

â¸»

CS 32 Project: Building a Custom Vector Container

Due Date: Flexible â€“ Self-paced project
Page: 1 of 4

â¸»

Overview

In this project, you will implement a dynamic array class Vector<T> from scratch, mimicking the behavior of std::vector. This will give you hands-on experience with class templates, operator overloading, dynamic memory management, and move semantics in C++.

You will implement dynamic resizing, support element access via the [] operator, implement copy and move constructors and assignment operators, and ensure safe memory handling using the Rule of Five.

â¸»

Learning Objectives
	â€¢	Implement a C++ class template from an abstract specification
	â€¢	Design and manage a dynamically allocated resizable array
	â€¢	Apply the Rule of Five for memory-safe resource management
	â€¢	Implement operator overloading ([], =, ==, !=)
	â€¢	Practice move semantics for efficient object transfer
	â€¢	Write clean, modular, and testable C++ code

â¸»

Real-World Use Cases

ðŸ§  Use Case 1: Fast Resizing Array

Build a generic resizable array for game objects, coordinates, or buffers in performance-sensitive programs.

ðŸ“¦ Use Case 2: Container for Any Type

Youâ€™ll design a class that can store any type â€” integers, strings, user-defined structs, etc.

ðŸ§ª Use Case 3: Efficient Test Runner

Store test case results, dynamically push results or messages, and use [] or iteration to access.

â¸»

What Youâ€™re Building
	â€¢	A Vector<T> class template (in Vector.h and Vector.cpp)
	â€¢	A test driver in main.cpp
	â€¢	A writeup in report.txt

All memory must be managed manually using new and delete. You may not use std::vector, std::array, or other STL containers internally.

â¸»

Required Functionality

You must implement the following public interface exactly as shown:

template <typename T>
class Vector {
public:
    Vector();                                     // Default constructor
    Vector(size_t initialCapacity);              // Optional: constructor with capacity
    ~Vector();                                    // Destructor

    Vector(const Vector<T>& other);              // Copy constructor
    Vector(Vector<T>&& other) noexcept;          // Move constructor

    Vector<T>& operator=(const Vector<T>& other); // Copy assignment
    Vector<T>& operator=(Vector<T>&& other) noexcept; // Move assignment

    void push_back(const T& value);              // Add item to end
    void pop_back();                             // Remove last item
    T& operator[](size_t index);                 // Access element
    const T& operator[](size_t index) const;

    size_t size() const;                         // Current number of elements
    size_t capacity() const;                     // Allocated capacity
    bool empty() const;                          // Is vector empty?

    void clear();                                // Remove all elements

    bool operator==(const Vector<T>& rhs) const; // Equality
    bool operator!=(const Vector<T>& rhs) const;

private:
    T* data;
    size_t sz;
    size_t cap;

    void resize(); // doubles the capacity
    void destroy(); // deletes all data
    void copyFrom(const Vector<T>& other);
};


â¸»

Constraints & Rules

You may not use:
	â€¢	Any STL container (e.g., std::vector, std::array, std::list)
	â€¢	Global variables (constants are fine)
	â€¢	friend or pragma
	â€¢	External libraries

You must:
	â€¢	Use new and delete safely
	â€¢	Follow Rule of Five
	â€¢	Use only raw pointers inside the implementation

â¸»

Starter Files

You should structure your code as:
	â€¢	Vector.h â€” class declaration
	â€¢	Vector.cpp â€” template method definitions
	â€¢	main.cpp â€” test driver (test all functionality + edge cases)
	â€¢	report.txt â€” explanation, pseudocode, and test plan

â¸»

What to Submit

You must submit a .zip file containing:
	â€¢	Vector.h, Vector.cpp, main.cpp, and report.txt

ðŸ“„ report.txt should include:
	â€¢	Your class design and pointer logic
	â€¢	Pseudocode for each major method
	â€¢	Description of how Rule of Five is implemented
	â€¢	Test strategy and edge cases handled

â¸»

Evaluation Criteria

Component	Points
Correct class design (template syntax, constructor setup)	10 pts
Dynamic memory management (new/delete, no leaks)	10 pts
Rule of Five (copy, move, destruct)	20 pts
Core functionality: push_back, pop_back, [], etc.	30 pts
Operator overloading (==, !=, [])	10 pts
Edge case handling (pop_back on empty, self-assignment, etc.)	10 pts
Clean code, modular structure, comments	5 pts
report.txt writeup and test cases	5 pts
Total	100 pts


â¸»

âœ… Must-Have Checklist
	â€¢	Template class structure with T* data, sz, cap
	â€¢	Safe new / delete usage
	â€¢	Push and pop logic with resizing
	â€¢	Overloaded [], ==, !=
	â€¢	Move semantics (Vector(Vector&&) and operator=(Vector&&))
	â€¢	Copy safety (deep copy, no shallow pointer aliasing)
	â€¢	No memory leaks (use Valgrind or equivalent to check)
	â€¢	Compile cleanly with g++ -std=c++17
	â€¢	Robust main.cpp with edge test cases
	â€¢	Clear, readable report.txt

â¸»

Let me know if youâ€™d like the starter code scaffolding (Vector.h, Vector.cpp, main.cpp) â€” I can generate that next.